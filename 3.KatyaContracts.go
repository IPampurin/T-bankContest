/*
У Кати насыщенный день на работе. Ей надо передать n разных договоров коллегам. Все встре- чи происходят на разных этажах, а между этажами
можно перемещаться только по лестничным пролетам — считается, что это улучшает физическую форму сотрудников.
Прохождение каждого пролета занимает ровно  минуту.
Сейчас Катя на парковочном этаже, планирует свой маршрут. Коллег можно посетить в любом порядке, но один из них покинет офис через  минут.
С парковочного этажа лестницы нет — только лифт, на котором можно подняться на любой этаж.
В итоге план Кати следующий:

Подняться на лифте на произвольный этаж. Считается, что лифт поднимается на любой этаж за  минут.
Передать всем коллегам договоры, перемещаясь между этажами по лестнице. Считается, что договоры на этаже передаются мгновенно.
В первые  минут передать договор тому коллеге, который планирует уйти.
Пройти минимальное количество лестничных пролетов.
Помогите Кате выполнить все пункты ее плана.

Формат входных данных
В первой строке вводятся целые положительные числа n и t (2<=n,t<=100) — количество сотрудников и время, когда один из сотрудников покинет офис (в минутах).
В следующей строке n чисел — номера этажей, на которых находятся сотрудники. Все числа различны и по абсолютной величине не превосходят 100.
Номера этажей даны в порядке возрастания. В следующей строке записан номер сотрудника, который уйдет через t минут.

Формат выходных данных
Выведите одно число — минимально возможное число лестничных пролетов, которое понадобится пройти Кате.

Замечание
В первом примере времени достаточно, чтобы Катя поднялась по этажам по порядку.
Во втором примере Кате понадобится подняться к уходящему сотруднику, а потом пройти всех остальных — например, в порядке {1,2,3,4,6}

Примеры данных
Пример 1
Ввод:
5  5
1  4  9  16  25
2
Вывод:
24

Пример 2
Ввод:
6  4
1  2  3  6  8  25
5
Вывод:
31
*/

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

// inputing считывает данные и возвращает введённые значения
func inputing(sc *bufio.Scanner) (int, int, []int, int) {

	// считываем ввод с первой строки
	sc.Scan()
	inputOne := strings.Split(sc.Text(), " ")
	// парсим входные данные
	// количество сотрудников
	n, err := strconv.Atoi(inputOne[0])
	// время хуода сотрудника workerOut
	timeOut, err := strconv.Atoi(inputOne[1])
	if err != nil {
		log.Fatal(err)
	}

	// floorNumbers слайс с номерами этажей, которые надо посетить
	floorNumbers := make([]int, 0, n)
	// добавим по нулевому индексу значение, чтобы в будущем не путаться с номерами этажей
	floorNumbers = append(floorNumbers, 0)
	// считываем ввод со второй строки
	sc.Scan()
	inputTwo := strings.Split(sc.Text(), " ")
	// парсим входные данные и пишем в floorNumbers
	for i := 0; i < n; i++ {
		num, err := strconv.Atoi(inputTwo[i])
		if err != nil {
			log.Fatal(err)
		}
		floorNumbers = append(floorNumbers, num)
	}

	// считываем ввод с третьей строки
	sc.Scan()
	// номер сотрудника, который уйдёт через timeOut минут
	workerOut, err := strconv.Atoi(sc.Text())
	if err != nil {
		log.Fatal(err)
	}

	return n, timeOut, floorNumbers, workerOut
}

// calculation вычисляет минимальное количество пролётов
func calculation(n, timeOut, workerOut int, floorNumbers []int) int {

	// для начала x это разница между максимумом и минимумом
	x := floorNumbers[len(floorNumbers)-1] - floorNumbers[1]

	downX := floorNumbers[workerOut] - floorNumbers[1]                 // количество пролётов от нижнего этажа до ухожденца
	upX := floorNumbers[len(floorNumbers)-1] - floorNumbers[workerOut] // количество пролётов от ухожденца до верхнего этажа

	// если можно подняться вовремя от нижнего сотрудника, то просто идём снизу через все этажи
	if downX < timeOut {
		return x
	}
	// если можно спуститься вовремя от верхнего сотрудника, то просто спускаемся сверху через все этажи
	if upX < timeOut {
		return x
	}
	// если ни подняться от нижнего сотрудника, ни спуститься от верхнего вовремя не удаётся,
	// идём сначала к уходящему, потом в сторону ближнего края, а потом в противоположный край
	if downX >= upX {
		x += upX
	} else {
		x += downX
	}

	return x
}

// outputing выводит результат
func outputing(out *bufio.Writer, x int) {

	fmt.Fprintf(out, "%v", x)
}

func main() {

	// определяем ввод
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanLines)

	// определяем вывод
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	// считываем введенные данные
	n, timeOut, floorNumbers, workerOut := inputing(scanner)

	// вычисляем минимальное количество пролётов
	x := calculation(n, timeOut, workerOut, floorNumbers)

	// выводим результат
	outputing(out, x)
}
